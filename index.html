<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fingerprint Label Simulator</title>
<style>
/* ═══════════════════════════════════════════════════════════════════
   RESET & TOKENS
═══════════════════════════════════════════════════════════════════ */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --bg:      #0e1117;
  --surf:    #161b22;
  --surf2:   #0d1117;
  --bdr:     #21262d;
  --bdr2:    #30363d;
  --txt:     #e6edf3;
  --muted:   #7d8590;
  --accent:  #58a6ff;
  --green:   #3fb950;
  --yellow:  #d29922;
  --red:     #f85149;
}
html, body { height: 100%; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: var(--bg); color: var(--txt); overflow: hidden; }

/* ═══  SHELL  ════════════════════════════════════════════════════════ */
#shell { display: flex; flex-direction: column; height: 100vh; }

/* ── Top bar ── */
#topbar {
  flex-shrink: 0; display: flex; align-items: center; height: 50px;
  background: var(--surf); border-bottom: 1px solid var(--bdr);
  padding: 0 14px; gap: 6px; overflow-x: auto;
}
.tb-brand {
  display: flex; align-items: center; gap: 10px;
  padding-right: 16px; border-right: 1px solid var(--bdr2); margin-right: 6px; flex-shrink: 0;
}
.tb-logo {
  width: 28px; height: 28px;
  background: linear-gradient(135deg, #1f6feb 0%, #58a6ff 100%);
  border-radius: 7px; display: flex; align-items: center; justify-content: center;
  font-size: 11px; font-weight: 900; color: #fff; letter-spacing: -1px; flex-shrink: 0;
}
.tb-brand h1  { font-size: 13px; font-weight: 700; line-height: 1.1; }
.tb-brand small { display: block; font-size: 10px; color: var(--muted); font-weight: 400; }
.tb-sep { width: 1px; height: 22px; background: var(--bdr2); flex-shrink: 0; margin: 0 4px; }
.tb-ctrl {
  display: flex; align-items: center; gap: 7px;
  font-size: 12px; color: var(--muted); white-space: nowrap; flex-shrink: 0;
}
.tb-ctrl input[type="range"] {
  -webkit-appearance: none; appearance: none; width: 130px; height: 4px;
  background: var(--bdr2); border-radius: 2px; outline: none; cursor: pointer;
}
.tb-ctrl input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none; appearance: none; width: 14px; height: 14px;
  border-radius: 50%; background: var(--accent); cursor: pointer;
}
.mono-val { font-family: ui-monospace, Consolas, monospace; font-size: 12px; color: var(--txt); min-width: 40px; }
.btn {
  display: inline-flex; align-items: center; gap: 6px;
  padding: 5px 11px; border-radius: 6px; border: 1px solid var(--bdr2);
  background: var(--surf2); color: var(--txt);
  font-size: 12px; font-weight: 600; cursor: pointer; white-space: nowrap;
  transition: filter .12s, background .12s, border-color .12s; flex-shrink: 0;
}
.btn:hover { filter: brightness(1.35); }
.btn.primary { background: #1f6feb; border-color: #388bfd; color: #fff; }
.btn.grid-on { background: #0c1e30; border-color: var(--accent); color: var(--accent); }
.btn.bbox-on { background: #0d2118; border-color: var(--green); color: var(--green); }
.live-chip {
  display: inline-flex; align-items: center; gap: 5px;
  padding: 3px 9px; border-radius: 999px;
  background: #0d2118; border: 1px solid var(--green);
  color: var(--green); font-size: 11px; font-weight: 700;
  letter-spacing: .4px; flex-shrink: 0;
}
.live-chip::before {
  content: ''; width: 6px; height: 6px; border-radius: 50%;
  background: var(--green);
  animation: pulse 1.4s ease-in-out infinite;
}
@keyframes pulse {
  0%,100% { opacity: 1; } 50% { opacity: .3; }
}

/* ── Status bar ── */
#statusBar {
  flex-shrink: 0; height: 24px; display: flex; align-items: center; gap: 10px;
  padding: 0 12px; background: var(--surf); border-top: 1px solid var(--bdr);
  font-size: 11px; color: var(--muted);
}
.stat-dot { width: 7px; height: 7px; border-radius: 50%; background: var(--green); flex-shrink: 0; }
.stat-dot.warn { background: var(--yellow); }
.stat-dot.err  { background: var(--red); }
#statusText { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

/* ── Body ── */
#content { flex: 1; display: flex; min-height: 0; }

/* ── Left: editor ── */
#editorPanel { width: 420px; flex-shrink: 0; display: flex; flex-direction: column; border-right: 1px solid var(--bdr); }
.panel-hdr {
  flex-shrink: 0; height: 32px; display: flex; align-items: center; justify-content: space-between;
  padding: 0 12px; background: var(--surf); border-bottom: 1px solid var(--bdr);
  font-size: 11px; font-weight: 700; color: var(--muted); text-transform: uppercase; letter-spacing: .5px;
}
#scriptInput {
  flex: 1; width: 100%; resize: none; border: 0; outline: 0; padding: 12px;
  background: var(--surf2); color: #c9d8eb;
  font-family: 'Cascadia Code', 'Fira Code', ui-monospace, Consolas, monospace;
  font-size: 12px; line-height: 1.55; tab-size: 2;
}
#parseLog {
  flex-shrink: 0; max-height: 115px; overflow-y: auto;
  background: #08090d; border-top: 1px solid var(--bdr);
  padding: 8px 12px;
  font-family: ui-monospace, Consolas, monospace; font-size: 11px; line-height: 1.65; color: var(--muted);
}
#parseLog .ok   { color: var(--green); }
#parseLog .warn { color: var(--yellow); }

/* ── Right: preview ── */
#previewPanel { flex: 1; display: flex; flex-direction: column; min-width: 0; }
#canvasScroll {
  flex: 1; overflow: auto; background: #07090d;
  padding: 24px; display: flex; justify-content: flex-start; align-items: flex-start;
}
#labelCanvas { display: block; flex-shrink: 0; background: #fff; box-shadow: 0 6px 44px rgba(0,0,0,.8); }
</style>
</head>
<body>
<div id="shell">

  <!-- ══ TOPBAR ══════════════════════════════════════════════════════════ -->
  <div id="topbar">
    <div class="tb-brand">
      <div class="tb-logo">FP</div>
      <div>
        <h1>Fingerprint Label Simulator</h1>
        <small>Intermec / Honeywell · Canvas-only renderer</small>
      </div>
    </div>

    <!-- Zoom -->
    <div class="tb-ctrl">
      <svg width="13" height="13" viewBox="0 0 16 16" fill="none" stroke="#7d8590" stroke-width="1.8"><circle cx="6.5" cy="6.5" r="5"/><line x1="11" y1="11" x2="15" y2="15"/><line x1="4" y1="6.5" x2="9" y2="6.5"/><line x1="6.5" y1="4" x2="6.5" y2="9"/></svg>
      Zoom
      <input type="range" id="zoom" min="0.1" max="1.5" step="0.025" value="0.36" />
      <span class="mono-val" id="zoomVal">0.36×</span>
    </div>

    <div class="tb-sep"></div>

    <!-- Grid toggle -->
    <button class="btn" id="btnGrid">
      <svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.4"><line x1="4" y1="0" x2="4" y2="12"/><line x1="8" y1="0" x2="8" y2="12"/><line x1="0" y1="4" x2="12" y2="4"/><line x1="0" y1="8" x2="12" y2="8"/></svg>
      Show Grid
    </button>

    <!-- Bounding boxes toggle -->
    <button class="btn" id="btnBBox">
      <svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.4"><rect x="1" y="1" width="10" height="10" rx="1" stroke-dasharray="3 2"/></svg>
      Bounding Boxes
    </button>

    <div class="tb-sep"></div>

    <!-- Live chip -->
    <span class="live-chip">LIVE</span>

    <div class="tb-sep"></div>

    <!-- Render -->
    <button class="btn primary" id="renderBtn">
      <svg width="12" height="12" viewBox="0 0 12 12" fill="currentColor"><polygon points="2,1 11,6 2,11"/></svg>
      Render
    </button>
  </div>

  <!-- ══ MAIN ════════════════════════════════════════════════════════════ -->
  <div id="content">

    <!-- Left: script editor -->
    <div id="editorPanel">
      <div class="panel-hdr">
        <span>Label Script</span>
        <span id="lineCount" style="font-weight:400">0 lines</span>
      </div>
      <textarea id="scriptInput" spellcheck="false" autocomplete="off"></textarea>
      <div id="parseLog"><span class="ok">Ready — paste your Fingerprint script and click Render.</span></div>
    </div>

    <!-- Right: canvas preview -->
    <div id="previewPanel">
      <div class="panel-hdr">
        <span>Label Preview</span>
        <span id="previewInfo" style="font-weight:400;font-family:monospace;font-size:10px"></span>
      </div>
      <div id="canvasScroll">
        <canvas id="labelCanvas"></canvas>
      </div>
    </div>

  </div>

  <!-- ══ STATUS BAR ═══════════════════════════════════════════════════════ -->
  <div id="statusBar">
    <div class="stat-dot" id="statDot"></div>
    <span id="statusText">Idle</span>
  </div>

</div><!-- /#shell -->

<script>
'use strict';
/* ═══════════════════════════════════════════════════════════════════════════
   COORDINATE SYSTEM
   ───────────────────────────────────────────────────────────────────────────
   Intermec / Honeywell Fingerprint uses:
     · Origin  = BOTTOM-LEFT corner of the label
     · Y axis  = UPWARD  (large Y → top of label)
     · X axis  = RIGHTWARD

   Confirmed by the data:
     · Y ≈ 2435  →  "L-SEQ:" appears at the very TOP   of the printed label
     · Y ≈ 40    →  corner tick marks at the BOTTOM

   Canvas (HTML5) uses top-left origin with Y downward, so we flip:
     canvasY = CANVAS_H − printerY
     canvasX = printerX   (unchanged)

   Canvas physical dot dimensions are derived from the label spec:
     Print density : 8 dpmm = 203 dpi
     Label size    : 4 × 6 inches
     Physical dots : 812 wide × 1218 tall

   The script was authored for a 406 dpi printer (Y max ≈ 2435 = 6 × 406,
   X max ≈ 1624 = 4 × 406).  A coordinate scale CS = 203/406 = 0.5 maps
   script dots → physical 203-dpi dots.  SCRIPT_W / SCRIPT_H are the canvas
   extents expressed in script-dot units (used for drawing and Y-flip).

   The zoom slider scales the visual display without touching dot coordinates.
═══════════════════════════════════════════════════════════════════════════ */

const PRINT_DPI  = 203;
const SCRIPT_DPI = 406;
const CS         = PRINT_DPI / SCRIPT_DPI;   // 0.5
// SCRIPT_W must cover all X values in the script (max observed: 1675 for box corner ticks).
// X increases from RIGHT→LEFT in Fingerprint: X=0 is right edge, X≈1675 is left edge.
const SCRIPT_W   = 1724;                     // script-dot width  (1675 + 49 margin)
const SCRIPT_H   = 6 * SCRIPT_DPI;          // 2436 script-dot height (6" × 406 dpi)
const CW         = Math.round(SCRIPT_W * CS); // 862 physical px wide
const CH         = Math.round(SCRIPT_H * CS); // 1218 physical px tall

/* Font base heights in dots, calibrated to:
     font1=12  font2=18  font3=28  font4=40  font8=120
   Each font height is multiplied by yMul from the command. */
const FONT_BASE = { 1:12, 2:18, 3:28, 4:40, 5:52, 6:68, 7:88, 8:90 };

const GRID_STEP = 50;   // grid line every N dots
const LEFT_OFFSET = 550; // shift content to the left
const DOWN_OFFSET = 150; // shift content down

// Y-flip: printer Y (bottom-left origin) → canvas Y (top-left)
function cy(printerY) { return SCRIPT_H - printerY + DOWN_OFFSET; }

// X-flip: printer X increases RIGHT→LEFT; canvas X increases LEFT→RIGHT.
// High printer X = left side of label; low printer X = right side.
function cx(printerX) { return SCRIPT_W - printerX - LEFT_OFFSET; }

/* ═══════════════════════════════════════════════════════════════════════════
   BAR PATTERN GENERATOR
   Deterministic Code-39-style bar array from a data string.
   No real encoding — purely visual simulation.
═══════════════════════════════════════════════════════════════════════════ */
function generateBars(data, moduleW, totalW) {
  let seed = 2166136261 >>> 0;
  for (let i = 0; i < data.length; i++) {
    seed ^= data.charCodeAt(i);
    seed  = Math.imul(seed, 16777619) >>> 0;
  }
  function rng() {
    seed ^= seed << 13; seed ^= seed >>> 17; seed ^= seed << 5;
    return seed >>> 0;
  }
  const narrow = Math.max(1, moduleW);
  const wide   = Math.max(2, moduleW * 3);
  const bars   = [];
  let x = 0, black = false;
  while (x < totalW - narrow) {
    const n = rng();
    const w = Math.min((n & 3) === 0 ? wide : narrow, totalW - x);
    bars.push({ x, w, black });
    x += w; black = !black;
  }
  return bars;
}

/* ═══════════════════════════════════════════════════════════════════════════
   PARSER   parseFingerprint(text) → { elements[], warnings[], cmdCount }
═══════════════════════════════════════════════════════════════════════════ */
function parseFingerprint(text) {
  const elements = [], warnings = [];
  let cmdCount = 0;

  for (let i = 0, lines = text.split(/\r?\n/); i < lines.length; i++) {
    const raw  = lines[i];
    const line = raw.trim();
    if (!line || line.startsWith('//')) continue;

    // Ignore all printer setup & control directives
    if (/^!Y\d|^!C(\s|$)|^!V\d|^!P[\s\d]/.test(line)) continue;
    if (!line.startsWith('!F')) {
      if (line.startsWith('!')) warnings.push({ lno: i + 1, msg: `Skipped: ${line}` });
      continue;
    }

    // ── !F T S  printerY  printerX  orient  fontId  xMul  yMul  "text" (standard)
    let m = line.match(/^!F\s+T\s+S\s+(-?\d+)\s+(-?\d+)\s+[A-Z]\s+(\d+)\s+(\d+)\s+(\d+)\s+"([^"]*)"\s*$/);
    if (m) { elements.push({ kind:'text',    y:+m[1], x:+m[2], fontId:+m[3], xMul:+m[4], yMul:+m[5], value:m[6],  lno:i+1 }); cmdCount++; continue; }

    // ── !F T S  printerY  printerX  C  fontId  extra1  extra2  rotation  "text" (rotated text with C)
    m = line.match(/^!F\s+T\s+S\s+(-?\d+)\s+(-?\d+)\s+C\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+"([^"]*)"\s*$/);
    if (m) { elements.push({ kind:'text',    y:+m[1], x:+m[2], fontId:+m[3], xMul:2, yMul:3, value:m[7], rotation:+m[6], lno:i+1 }); cmdCount++; continue; }

    // ── !F B N/E  printerY  printerX  L  thickness  length (line)
    m = line.match(/^!F\s+B\s+([NE])\s+(-?\d+)\s+(-?\d+)\s+[A-Z]\s+(\d+)\s+(\d+)\s*$/);
    if (m) {
      elements.push({ kind:'line', dir:m[1], y:+m[2], x:+m[3], thickness:+m[4], length:+m[5], lno:i+1 });
      cmdCount++; continue;
    }

    // ── !F B S  printerY  printerX  L  height  width  thickness (box/rectangle)
    m = line.match(/^!F\s+B\s+S\s+(-?\d+)\s+(-?\d+)\s+[A-Z]\s+(\d+)\s+(\d+)\s+(\d+)\s*$/);
    if (m) {
      elements.push({ kind:'box', y:+m[1], x:+m[2], width:+m[4], height:+m[3], thickness:+m[5], lno:i+1 });
      cmdCount++; continue;
    }

    // ── !F C S  printerY  printerX  orient  height  moduleW  extra  "data"
    m = line.match(/^!F\s+C\s+S\s+(-?\d+)\s+(-?\d+)\s+[A-Z]\s+(\d+)\s+(\d+)\s+(\d+)\s+"([^"]*)"\s*$/);
    if (m) { elements.push({ kind:'barcode', y:+m[1], x:+m[2], height:+m[3], moduleW:+m[4], extra:+m[5], value:m[6], lno:i+1 }); cmdCount++; continue; }

    warnings.push({ lno: i + 1, msg: `Unparsed: ${line}` });
  }
  return { elements, warnings, cmdCount };
}

/* ═══════════════════════════════════════════════════════════════════════════
   DRAW:  LINES & CORNER BRACKETS
   Short !F B commands (length ≤ 100) are grouped into bounding rectangles.
   Each rectangle produces exactly four L-shaped corner brackets:
     ┌ top-left  ┐ top-right  └ bottom-left  ┘ bottom-right
   Long commands (length > 100) are plain separator strokes.
═══════════════════════════════════════════════════════════════════════════ */
const BRACKET_ARM = 80;   // arm length in script-dots → ~40 physical dots

/* Draw one L-shaped corner at canvas (cvX, cvY).
   hDir: +1 = arm goes right, -1 = arm goes left.
   vDir: +1 = arm goes down,  -1 = arm goes up.        */
function drawCorner(ctx, cvX, cvY, hDir, vDir, thickness) {
  const s = BRACKET_ARM;
  ctx.save();
  ctx.strokeStyle = '#000';
  ctx.lineWidth   = thickness;
  ctx.lineCap     = 'square';
  ctx.beginPath();
  ctx.moveTo(cvX,         cvY);
  ctx.lineTo(cvX + hDir * s, cvY);             // horizontal arm
  ctx.moveTo(cvX,         cvY);
  ctx.lineTo(cvX,         cvY + vDir * s);     // vertical arm
  ctx.stroke();
  ctx.restore();
}

function drawLines(ctx, lineEls) {
  // ── Separator / rule lines (long strokes) ────────────────────────────────
  for (const el of lineEls.filter(e => e.length > 100)) {
    // Skip long vertical guide lines only (dir E, thin, long) — never skip horizontal (N) lines.
    const isVertical = el.dir === 'E';
    const isVerticalN = el.dir === 'N';
    if (isVertical && el.thickness <= 5 && el.length > 500) continue;
    // Skip the vertical separator line below barcode (N direction, long line in barcode area)
    if (isVerticalN && el.length > 500 && el.y < 800) continue;
    ctx.save();
    ctx.strokeStyle = '#000';
    ctx.lineWidth   = Math.max(1, el.thickness);
    ctx.lineCap     = 'square';
    ctx.beginPath();
    ctx.moveTo(cx(el.x), cy(el.y));
    if (el.dir === 'E') ctx.lineTo(cx(el.x) + el.length, cy(el.y));
    else                ctx.lineTo(cx(el.x), cy(el.y - el.length));
    ctx.stroke();
    ctx.restore();
  }

  // ── Group short anchors into rectangles by matching X extent ─────────────
  const anchors = lineEls.filter(e => e.length <= 100);
  if (anchors.length < 4) return;

  // Build a map: Y → { xMin, xMax, thickness }
  const byY = new Map();
  for (const el of anchors) {
    if (!byY.has(el.y)) byY.set(el.y, { xMin: el.x, xMax: el.x, thickness: el.thickness });
    else {
      const e = byY.get(el.y);
      if (el.x < e.xMin) e.xMin = el.x;
      if (el.x > e.xMax) e.xMax = el.x;
    }
  }

  // Pair Y-edges that share the same X extent → one rectangle per pair.
  const edges   = [...byY.entries()].map(([y, e]) => ({ y, ...e }));
  const matched = new Set();
  const rects   = [];

  for (let i = 0; i < edges.length; i++) {
    if (matched.has(i)) continue;
    for (let j = i + 1; j < edges.length; j++) {
      if (matched.has(j)) continue;
      const a = edges[i], b = edges[j];
      if (a.xMin === b.xMin && a.xMax === b.xMax) {
        rects.push({ yMin: Math.min(a.y, b.y), yMax: Math.max(a.y, b.y),
                     xMin: a.xMin, xMax: a.xMax, thickness: a.thickness });
        matched.add(i); matched.add(j);
        break;
      }
    }
  }

  // Draw four L-shaped corners for each rectangle.
  // Skip the barcode-area anchor group (yMin < 1100) — those are positioning
  // anchors only; the receiver frame always has yMin ≥ 1100.
  for (const r of rects) {
    if (r.yMin < 1100) continue;
    // Left bracket aligned to "FI-Finland" text start (printer X=990) minus a small gap.
    const L  = cx(990) - 6 * CS;
    const R  = Math.max(cx(r.xMin), cx(r.xMax)) - 120;   // canvas right, shifted left
    const T  = Math.min(cy(r.yMin), cy(r.yMax));         // canvas top
    const B  = Math.max(cy(r.yMin), cy(r.yMax));         // canvas bottom

    drawCorner(ctx, L, T, +1, +1, r.thickness);   // ┌ top-left
    drawCorner(ctx, R, T, -1, +1, r.thickness);   // ┐ top-right
    drawCorner(ctx, L, B, +1, -1, r.thickness);   // └ bottom-left
    drawCorner(ctx, R, B, -1, -1, r.thickness);   // ┘ bottom-right
  }
}


/* ═══════════════════════════════════════════════════════════════════════════
   DRAW:  TEXT
   (el.x, el.y) = bottom-left of character cell baseline in printer coords.
   FontId selects base height; yMul scales it; xMul/yMul ratio adjusts width.
═══════════════════════════════════════════════════════════════════════════ */
function drawText(ctx, el) {
  if (!el.value) return;
  // Base font size only — do NOT multiply by xMul or yMul.
  const BASE = { 1:12, 2:18, 3:28, 4:40, 5:52, 6:68, 7:88, 8:48 };
  const sizePx     = BASE[el.fontId] || 18;
  const widthScale = el.xMul || 1;
  const heightScale = el.yMul || 1;
  ctx.save();
  ctx.fillStyle    = '#000';
  ctx.textBaseline = 'alphabetic';
  ctx.textAlign    = 'left';
  // Translate to position, then scale for width/height stretch independently.
  ctx.translate(cx(el.x), cy(el.y));
  ctx.scale(widthScale, heightScale);
  ctx.font = `${sizePx}px "Courier New", monospace`;
  ctx.fillText(el.value, 0, 0);
  ctx.restore();
}

/* ═══════════════════════════════════════════════════════════════════════════
   DRAW:  BARCODE PLACEHOLDER
   (el.x, el.y) = bottom-left corner of the barcode in printer coordinates.
   The barcode rectangle extends UPWARD by `el.height` dots from that point.
═══════════════════════════════════════════════════════════════════════════ */
function drawBarcode(ctx, el) {
  const mw    = Math.max(1, el.moduleW);
  const barH  = Math.max(20, el.height);
  const data  = el.value || '';
  // (el.x, el.y) = lower-left corner of barcode in printer coords.
  // cx(el.x) = left edge on canvas (high printer X = left side of label).
  // Barcode extends RIGHTWARD on the physical label = increasing canvas X.
  const cvX   = cx(el.x);                    // left edge of barcode on canvas
  const barW  = (data.length * 11 + 35) * mw; // calculate full width needed
  const cvY   = cy(el.y);                    // bottom of barcode area on canvas

  ctx.save();
  // White background for barcode area
  ctx.fillStyle = '#fff';
  ctx.fillRect(cvX, cvY - barH, barW, barH);
  // Simulated bars
  const bars = generateBars(data, mw, barW);
  ctx.fillStyle = '#000';
  for (const b of bars) {
    if (b.black) ctx.fillRect(cvX + b.x, cvY - barH + 3, b.w, barH - 6);
  }
  // Human-readable text below — centered
  if (data) {
    const fs = Math.max(10, Math.min(18, mw * 3));
    ctx.fillStyle    = '#000';
    ctx.font         = `${fs}px "Courier New", monospace`;
    ctx.textBaseline = 'top';
    ctx.textAlign    = 'center';
    ctx.fillText(data, cvX + barW / 2, cvY + 2);
  }
  ctx.restore();
}

/* ═══════════════════════════════════════════════════════════════════════════
   DRAW:  BOX / RECTANGLE
   (el.x, el.y) = bottom-left corner of the box in printer coordinates.
   Box extends RIGHTWARD by width and UPWARD by height.
═══════════════════════════════════════════════════════════════════════════ */
function drawBox(ctx, el) {
  const cvX = cx(el.x);                  // left edge on canvas
  const cvY = cy(el.y + el.height);      // top edge on canvas
  ctx.save();
  ctx.strokeStyle = '#000';
  ctx.lineWidth   = Math.max(1, el.thickness);
  ctx.strokeRect(cvX, cvY, el.width, el.height);
  ctx.restore();
}

/* ═══════════════════════════════════════════════════════════════════════════
   DRAW:  GRID OVERLAY  (every GRID_STEP dots)
═══════════════════════════════════════════════════════════════════════════ */
function drawGrid(ctx) {
  ctx.save();
  ctx.strokeStyle = 'rgba(88,166,255,0.10)';
  ctx.lineWidth   = 0.5;
  ctx.setLineDash([2, 5]);
  for (let x = 0; x <= SCRIPT_W; x += GRID_STEP) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, SCRIPT_H); ctx.stroke(); }
  for (let y = 0; y <= SCRIPT_H; y += GRID_STEP) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(SCRIPT_W, y); ctx.stroke(); }
  ctx.setLineDash([]);
  ctx.fillStyle = 'rgba(88,166,255,0.45)';
  ctx.font = '10px ui-monospace, Consolas, monospace';
  ctx.textBaseline = 'top'; ctx.textAlign = 'left';
  // Grid labels show PRINTER coordinates (X flipped back, Y flipped back)
  for (let px = 200; px < SCRIPT_W; px += 200) {
    const printerX = SCRIPT_W - px;  // restore printer coord for display
    ctx.fillText('X' + printerX, px + 2, 2);
  }
  ctx.textAlign = 'right';
  for (let py = 200; py < SCRIPT_H; py += 200) {
    const printerY = SCRIPT_H - py;
    if (printerY > 0) ctx.fillText('Y' + printerY, SCRIPT_W - 2, py + 2);
  }
  ctx.restore();
}

/* ═══════════════════════════════════════════════════════════════════════════
   DRAW:  BOUNDING BOXES
   Draws colour-coded AABB around every element with its printer (x,y) label.
   Green = text   Orange = line   Red = barcode
═══════════════════════════════════════════════════════════════════════════ */
function drawBBoxes(ctx, elements) {
  const clr = { text:'rgba(63,185,80,.7)', line:'rgba(255,160,30,.7)', barcode:'rgba(248,81,73,.7)', box:'rgba(138,75,175,.7)' };
  ctx.save();
  ctx.setLineDash([3, 3]);
  ctx.lineWidth = 1;
  ctx.font = '9px ui-monospace, Consolas, monospace';
  ctx.textBaseline = 'top';

  for (const el of elements) {
    const col = clr[el.kind] || 'rgba(255,255,255,.5)';
    let bx, by, bw, bh;

    if (el.kind === 'text') {
      if (!el.value) continue;
      const sz = (FONT_BASE[el.fontId] || 18) * (el.yMul || 1);
      const stretch = (el.xMul && el.yMul) ? el.xMul / el.yMul : 1;
      bw = el.value.length * sz * 0.6 * stretch;
      bh = sz;
      bx = cx(el.x); by = cy(el.y) - bh * 0.85;
    } else if (el.kind === 'line') {
      const t = Math.max(1, el.thickness);
      if (el.dir === 'E') { bx = cx(el.x); by = cy(el.y) - t / 2; bw = el.length; bh = t; }
      else                { bx = cx(el.x) - t / 2; by = cy(el.y);              bw = t; bh = el.length; }
    } else if (el.kind === 'barcode') {
      const mw = Math.max(1, el.moduleW);
      const barH = Math.max(20, el.height);
      const barW = (el.value.length * 11 + 35) * mw;
      const textH = el.value ? Math.max(10, Math.min(18, mw * 3)) + 4 : 0;
      bx = cx(el.x);
      by = cy(el.y) - barH;
      bw = barW;
      bh = barH + textH;
    } else if (el.kind === 'box') {
      bx = cx(el.x);
      by = cy(el.y + el.height);
      bw = el.width;
      bh = el.height;
    } else continue;

    ctx.strokeStyle = col;
    ctx.strokeRect(bx, by, bw, bh);
    ctx.setLineDash([]);
    ctx.fillStyle = col;
    ctx.fillText(`(${el.x},${el.y})`, bx + 2, by + 1);
    ctx.setLineDash([3, 3]);
  }
  ctx.restore();
}

/* ═══════════════════════════════════════════════════════════════════════════
   MAIN RENDER FUNCTION
   renderLabel(elements, { zoom, showGrid, showBBox })
═══════════════════════════════════════════════════════════════════════════ */
function renderLabel(elements, { zoom = 0.36, showGrid = false, showBBox = false } = {}) {
  const canvas = document.getElementById('labelCanvas');
  const dpr    = window.devicePixelRatio || 1;
  const scale  = zoom * dpr;

  // Backing-store size: physical label dots × zoom × DPR
  canvas.width  = Math.round(CW * scale);
  canvas.height = Math.round(CH * scale);
  // CSS display size (zoom only — DPR handled by transform)
  canvas.style.width  = Math.round(CW * zoom) + 'px';
  canvas.style.height = Math.round(CH * zoom) + 'px';

  const ctx = canvas.getContext('2d');
  // Transform: 1 script-dot → CS physical dots → scale pixels.
  // All draw calls use script-dot coordinates; CS shrinks them to physical dots.
  ctx.setTransform(scale * CS, 0, 0, scale * CS, 0, 0);

  // ── White paper ────────────────────────────────────────────────────────────
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, SCRIPT_W, SCRIPT_H);

  // ── Grid (drawn first, under everything) ───────────────────────────────────
  if (showGrid) drawGrid(ctx);

  // ── Content: lines → boxes → barcodes → text ──────────────────────────────────────
  drawLines(ctx, elements.filter(el => el.kind === 'line'));
  for (const el of elements) if (el.kind === 'box')     drawBox(ctx, el);
  for (const el of elements) if (el.kind === 'barcode') drawBarcode(ctx, el);
  for (const el of elements) if (el.kind === 'text')    drawText(ctx, el);

  // ── Bounding boxes (drawn on top) ─────────────────────────────────────────
  if (showBBox) drawBBoxes(ctx, elements);

  // ── Thin outer frame ───────────────────────────────────────────────────────
  ctx.strokeStyle = 'rgba(0,0,0,0.10)';
  ctx.lineWidth   = 1;
  ctx.setLineDash([]);
  ctx.strokeRect(0.5, 0.5, SCRIPT_W - 1, SCRIPT_H - 1);

  document.getElementById('previewInfo').textContent =
    `4 × 6 in · 203 dpi (8 dpmm) · ${CW}×${CH} physical dots · ${Math.round(zoom * 100)}% · DPR ${dpr}`;
}

/* ═══════════════════════════════════════════════════════════════════════════
   UI
═══════════════════════════════════════════════════════════════════════════ */
let showGrid = false;
let showBBox = false;

function doRender() {
  const script = document.getElementById('scriptInput').value;
  const zoom   = parseFloat(document.getElementById('zoom').value || '0.36');

  const t0 = performance.now();
  const { elements, warnings, cmdCount } = parseFingerprint(script);
  renderLabel(elements, { zoom, showGrid, showBBox });
  const ms = (performance.now() - t0).toFixed(1);

  // Parse log
  const n = { text: 0, line: 0, barcode: 0, box: 0 };
  for (const el of elements) n[el.kind] = (n[el.kind] || 0) + 1;
  const rows = [
    `<span class="ok">✔ ${cmdCount} command(s) · text:${n.text} · lines:${n.line} · boxes:${n.box} · barcodes:${n.barcode} · ${ms}ms</span>`,
    ...warnings.map(w => `<span class="warn">⚠ L${w.lno}: ${esc(w.msg)}</span>`),
  ];
  document.getElementById('parseLog').innerHTML = rows.join('<br>');

  // Status bar
  const dot = document.getElementById('statDot');
  dot.className = warnings.length ? 'stat-dot warn' : 'stat-dot';
  document.getElementById('statusText').textContent = warnings.length
    ? `Rendered with ${warnings.length} warning(s) — see Parse Log`
    : `Rendered · ${cmdCount} elements · zoom ${Math.round(zoom * 100)}%`;
}

function esc(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

// Zoom
document.getElementById('zoom').addEventListener('input', function () {
  document.getElementById('zoomVal').textContent = parseFloat(this.value).toFixed(2) + '×';
  doRender();
});

// Render button
document.getElementById('renderBtn').addEventListener('click', doRender);

// Grid toggle
document.getElementById('btnGrid').addEventListener('click', function () {
  showGrid = !showGrid;
  this.classList.toggle('grid-on', showGrid);
  this.innerHTML = showGrid
    ? '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.4"><line x1="4" y1="0" x2="4" y2="12"/><line x1="8" y1="0" x2="8" y2="12"/><line x1="0" y1="4" x2="12" y2="4"/><line x1="0" y1="8" x2="12" y2="8"/></svg> Hide Grid'
    : '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.4"><line x1="4" y1="0" x2="4" y2="12"/><line x1="8" y1="0" x2="8" y2="12"/><line x1="0" y1="4" x2="12" y2="4"/><line x1="0" y1="8" x2="12" y2="8"/></svg> Show Grid';
  doRender();
});

// BBox toggle
document.getElementById('btnBBox').addEventListener('click', function () {
  showBBox = !showBBox;
  this.classList.toggle('bbox-on', showBBox);
  this.innerHTML = showBBox
    ? '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.4"><rect x="1" y="1" width="10" height="10" rx="1" stroke-dasharray="3 2"/></svg> Hide Bounding Boxes'
    : '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.4"><rect x="1" y="1" width="10" height="10" rx="1" stroke-dasharray="3 2"/></svg> Bounding Boxes';
  doRender();
});

// Live auto-render: re-render 400 ms after the user stops typing (Labelary-style)
let _autoRenderTimer = null;
document.getElementById('scriptInput').addEventListener('input', function () {
  document.getElementById('lineCount').textContent = this.value.split('\n').length + ' lines';
  clearTimeout(_autoRenderTimer);
  _autoRenderTimer = setTimeout(doRender, 400);
});

/* ═══════════════════════════════════════════════════════════════════════════
   DEFAULT SCRIPT  (IKEA ILSE shipping label)
═══════════════════════════════════════════════════════════════════════════ */
document.getElementById('scriptInput').value = `!Y37 0
!Y66 0
!Y17 2
!Y34 10000
!Y68 0
!Y69 -50
!Y17 2
!Y100 0
!Y9 0
!V3194
!C
!Y35 10
!Y72 2
!Y73 3
!Y74 4
!Y75 5
!Y76 6
!Y101 0
!Y102 0
!Y103 0
!Y104 0
!Y105 0
!Y106 0

!F T S 1911 990 L 2 1 1 "Från"
!F T S 1867 990 L 2 1 3 "202 Ikea Espoo"
!F T S 1818 990 L 2 1 3 "Espoontie 21"
!F T S 1768 990 L 2 1 3 "02740 Espoo"
!F T S 1737 990 L 2 1 1 "Tel:"
!F T S 1739 935 L 1 1 3 ""
!F T S 1737 493 L 2 1 1 "Avs-datum:"
!F T S 1739 370 L 1 1 3 "2025-01-31"

!F B E 1000 1675 L 10 50
!F B N 1725 960 L 10 50
!F B E 40 1675 L 10 50
!F B E 40 1226 L 10 50
!F B N 1236 40 L 10 50
!F B N 1725 40 L 10 50
!F B N 1236 960 L 10 50
!F B E 1000 1226 L 10 50

!F T S 1692 990 L 2 1 1 "Till"
!F T S 1628 990 L 3 2 3 "Felipe Gadea Llopis"
!F T S 1535 990 L 2 2 3 "Kilterinkaari 2 C 67"
!F T S 1480 990 L 2 2 3 ""

!F T S 1406 990 L 3 2 3 "01600"
!F T S 1406 770 L 3 2 3 "Vantaa"

!F T S 1250 990 L 4 3 3 "FI-Finland"

!F T S 1334 1020 L 2 2 1 ""
!F T S 1304 1020 L 2 2 1 ""
!F T S 1274 1020 L 2 2 1 ""
!F T S 1244 1020 L 2 2 1 ""

!F T S 1000 620 L 8 4 3 ""
!F T S 1000 320 L 8 4 3 ""
!F T S 1000 990 L 8 4 3 "ILSE"

!F T S 759 1020 L 2 1 1 "Sänd-ID:"
!F T S 759 925 L 2 1 3 "1496046443592379003"
!F T S 759 579 L 2 1 1 "Kolli:"
!F T S 759 509 L 2 1 3 "1"
!F T S 759 400 L 2 1 1 "Kollivikt:"
!F T S 759 279 L 3 2 3 "25,09"
!F T S 759 80 L 2 1 1 "kg"
!F B N 757 50 L 5 990

!Y42 0
!F C S 424 922 L 310 4 41 "1496046443592379003"
!F T S 389 952 L 2 1 4 "Kolli-ID:"
!F T S 285 960 L 2 2 5 "1496046443592403759"

//IKEA CDU

!F T S 2435 1020 L 1 1 3 "L-SEQ: "
!F T S 2395 1020 L 1 1 3 "LS:    "
!F T S 2355 1020 L 1 1 3 "OID:   384524072"
!F T S 2300 1020 L 2 2 3 "CDU: 42c5cb 89-54fd -4316"
!F T S 2250 1020 L 2 2 3 "Box Id: @BI@"
!F T S 2250 520 L 2 2 3 "LSC: 202"
!F T S 2200 1020 L 2 2 3 "TRIP: 202 1"
!F T S 2200 520 L 2 2 3 "GATE: @GAT@"
!F T S 2377 570 L 4 2 3 "ILSE  "

!Y42 0
!F C S 1970 952 L 220 5 41 "42c5cb89-54fd-4316-b3e8-dfbe12e32e33"
!F T S 1932 730 L 1 1 5 "42c5cb89-54fd-4316-b3e8-dfbe12e32e33"
!P 1

!C
!C`;

// ── Init ──
(function () {
  const lines = document.getElementById('scriptInput').value.split('\n').length;
  document.getElementById('lineCount').textContent = lines + ' lines';
  document.getElementById('zoomVal').textContent =
    parseFloat(document.getElementById('zoom').value).toFixed(2) + '×';
  doRender();
})();
</script>
</body>
</html>
